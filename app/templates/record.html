{% extends "base.html" %}

{% block title %}Record Log Entry - Captain's Log{% endblock %}

{% block page_title %}LOG RECORDER{% endblock %}

{% block head %}
<style>
    /* Override the scrolling from base template */
    .lcars-content {
        overflow-y: hidden !important;
        height: 100%;
    }

    .recording-interface {
        display: flex;
        height: calc(100vh - 160px);
        gap: 0;
        margin: 0;
        overflow: hidden;
    }

    .main-content {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 0;
        overflow: hidden;
    }

    .lcars-sidebar {
        width: 200px;
        background: var(--lcars-black);
        border-radius: 0 15px 15px 0;
        display: flex;
        flex-direction: column;
        padding: 0;
        margin-left: 2px;
        position: relative;
    }

    .central-display {
        background: linear-gradient(45deg, rgba(255, 153, 0, 0.1), rgba(153, 153, 204, 0.1));
        border: none;
        border-radius: 15px;
        padding: 0;
        flex: 1;
        max-height: 80%;
        position: relative;
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .display-content {
        width: 100%;
        height: 100%;
        background-color: var(--lcars-bg);
        border-radius: 10px;
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .waveform-bars {
        display: flex;
        align-items: end;
        gap: 2px;
        height: 80%;
        width: 100%;
        opacity: 0;
        transition: opacity 0.3s ease;
        justify-content: center;
    }

    .waveform-bars.active {
        opacity: 1;
    }

    .waveform-bar {
        width: 4px;
        background: linear-gradient(to top, var(--lcars-orange), var(--lcars-red));
        border-radius: 2px;
        transition: height 0.1s ease;
        min-height: 2px;
    }

    #video-display {
        width: 100%;
        height: 100%;
        border-radius: 8px;
        background: var(--lcars-black);
        object-fit: cover;
    }

    .recording-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.3s ease;
        font-family: 'lcars', 'Helvetica Neue', 'Arial Narrow', sans-serif;
        font-weight: bold;
        font-size: 2em;
        text-transform: uppercase;
        color: var(--lcars-white);
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
        z-index: 10;
    }

    .recording-overlay:hover {
        background: rgba(0, 0, 0, 0.5);
    }

    .recording-overlay.transparent {
        background: transparent;
        color: transparent;
    }

    .recording-overlay.transparent:hover {
        background: transparent;
    }

    .sidebar-section {
        background: var(--lcars-gray);
        border-bottom: 2px solid var(--lcars-black);
        padding: 15px 20px;
        font-family: 'lcars', 'Helvetica Neue', 'Arial Narrow', sans-serif;
        font-weight: bold;
        font-size: 16px;
        text-transform: uppercase;
        color: var(--lcars-black);
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .sidebar-section:first-child {
        border-radius: 0 15px 0 0;
    }

    .sidebar-section:last-child {
        border-radius: 0 0 15px 0;
        border-bottom: none;
    }

    .sidebar-section.timer {
        background: var(--lcars-orange);
        font-size: 24px;
        letter-spacing: 2px;
        min-height: 60px;
    }

    .sidebar-section.control-btn {
        cursor: pointer;
        transition: all 0.3s ease;
        background: var(--lcars-blue);
        min-height: 50px;
    }

    .sidebar-section.control-btn:hover:not(.disabled) {
        filter: brightness(1.15);
        box-shadow: inset 0 0 10px rgba(0,0,0,0.2);
    }

    .sidebar-section.control-btn.disabled {
        background: #666;
        cursor: not-allowed;
        opacity: 0.5;
    }

    .sidebar-section.control-btn.record-btn {
        background: var(--lcars-red);
        color: var(--lcars-white);
    }

    .sidebar-section.control-btn.record-btn.recording {
        background: #ff4444;
        animation: recordingPulse 1.5s infinite;
    }

    .sidebar-section.control-btn.record-btn.stopped {
        background: var(--lcars-orange);
        color: var(--lcars-black);
    }

    .sidebar-section.control-btn.danger {
        background: var(--lcars-red);
        color: white;
    }

    .sidebar-section.control-btn.secondary {
        background: var(--lcars-orange);
    }


    .sidebar-section.lcars-thin {
        background: var(--lcars-blue);
        height: 20px;
        border-bottom: 2px solid var(--lcars-black);
    }

    .sidebar-section.lcars-taper {
        background: var(--lcars-orange);
        height: 120px;
        border-bottom: none !important;
        border-radius: 0 0 100% 0;
        position: relative;
        overflow: hidden;
    }

    @keyframes recordingPulse {
        0% {
            box-shadow: 0 0 0 0 rgba(255, 68, 68, 0.7);
            transform: scale(1);
        }
        50% {
            box-shadow: 0 0 0 20px rgba(255, 68, 68, 0);
            transform: scale(1.05);
        }
        100% {
            box-shadow: 0 0 0 0 rgba(255, 68, 68, 0);
            transform: scale(1);
        }
    }

    .recording-status {
        text-align: center;
        padding: 15px;
        background: rgba(255, 153, 0, 0.1);
        border-radius: 10px;
        border: 2px solid var(--lcars-orange);
        order: -1;
    }

    .status-text {
        font-size: 1.2em;
        font-weight: bold;
        text-transform: uppercase;
    }

    .recording-timer {
        font-size: 2em;
        color: var(--lcars-orange);
        font-weight: bold;
        margin: 10px 0;
    }

    .upload-progress {
        display: none;
        margin-top: 20px;
    }

    .progress-container {
        position: relative;
        margin: 20px 0;
    }

    #alerts {
        height: 62px;
        overflow-y: auto;
        margin-bottom: 0;
        flex-shrink: 0;
        border: 2px solid var(--lcars-orange);
        border-radius: 30px 0 0 0;
        box-sizing: border-box;
    }

    .lcars-alert {
        padding: 15px;
        border-radius: 10px;
        margin-bottom: 10px;
        font-weight: bold;
        text-transform: uppercase;
    }

    .lcars-alert:last-child {
        margin-bottom: 0;
    }

    .lcars-alert.error {
        background-color: rgba(204, 102, 102, 0.2);
        border: 2px solid var(--lcars-red);
        color: var(--lcars-red);
    }

    .lcars-alert.success {
        background-color: rgba(153, 204, 153, 0.2);
        border: 2px solid var(--lcars-green);
        color: var(--lcars-green);
    }

    .lcars-alert.info {
        background-color: rgba(153, 153, 204, 0.2);
        border: 2px solid var(--lcars-blue);
        color: var(--lcars-blue);
    }

</style>
{% endblock %}

{% block content %}
<div class="recording-interface">
    <div class="main-content">
        <!-- Alerts -->
        <div id="alerts"></div>

        <!-- Central Display -->
        <div class="central-display">
            <div class="display-content">
                <!-- Video Display (shown when video mode is selected) -->
                <video id="video-display" autoplay muted playsinline style="display: none;"></video>

                <!-- Waveform Display (shown when audio mode is selected) -->
                <div class="waveform-bars" id="waveform">
                    <!-- Waveform bars will be generated by JavaScript -->
                </div>
                <div id="waveform-placeholder" style="display: none;"></div>

                <!-- Recording Overlay -->
                <div class="recording-overlay" id="recording-overlay">
                    START RECORDING
                </div>
            </div>
        </div>
    </div>

    <!-- LCARS Sidebar -->
    <div class="lcars-sidebar">
        <div class="sidebar-section timer" id="timer">00:00</div>
        <div class="sidebar-section control-btn secondary" onclick="switchMode()" id="mode-toggle">RECORD VIDEO LOG</div>
        <div class="sidebar-section control-btn disabled" id="save-btn" onclick="saveRecording()" style="display: none;">SAVE</div>
        <div class="sidebar-section control-btn danger" id="cancel-btn" onclick="cancelRecording()" style="display: none;">CANCEL</div>
        <div class="sidebar-section lcars-thin"></div>
        <div class="sidebar-section lcars-taper">
        </div>
    </div>

    <!-- Upload Progress -->
    <div class="upload-progress" id="upload-progress">
        <h3 style="color: var(--lcars-blue);">PROCESSING LOG ENTRY</h3>
        <div class="progress-container">
            <div class="lcars-progress">
                <div class="lcars-progress-bar" id="progress-bar" style="width: 0%"></div>
                <div class="lcars-progress-text" id="progress-text">0%</div>
            </div>
        </div>
        <div style="font-size: 0.9em; color: var(--lcars-blue); margin-top: 10px;" id="progress-status">
            Preparing upload...
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    class VoiceRecorder {
        constructor() {
            this.mediaRecorder = null;
            this.audioContext = null;
            this.analyser = null;
            this.microphone = null;
            this.chunks = [];
            this.isRecording = false;
            this.isPaused = false;
            this.startTime = null;
            this.pausedTime = 0;
            this.timerInterval = null;
            this.animationId = null;
            this.currentStream = null;
            this.isVideoMode = false;

            this.saveBtn = document.getElementById('save-btn');
            this.cancelBtn = document.getElementById('cancel-btn');
            this.modeToggle = document.getElementById('mode-toggle');
            this.timer = document.getElementById('timer');
            this.waveform = document.getElementById('waveform');
            this.waveformPlaceholder = document.getElementById('waveform-placeholder');
            this.videoDisplay = document.getElementById('video-display');
            this.recordingOverlay = document.getElementById('recording-overlay');

            this.initializeWaveform();
            this.updateUI();
        }

        initializeWaveform() {
            // Create 60 waveform bars
            for (let i = 0; i < 60; i++) {
                const bar = document.createElement('div');
                bar.className = 'waveform-bar';
                bar.style.height = '2px';
                this.waveform.appendChild(bar);
            }
        }


        async switchToVideoMode() {
            this.isVideoMode = true;
            this.waveform.style.display = 'none';
            this.waveformPlaceholder.style.display = 'none';
            this.videoDisplay.style.display = 'block';
            this.modeToggle.textContent = 'RECORD AUDIO LOG';

            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 1280 },
                        height: { ideal: 720 },
                        facingMode: 'user'
                    },
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        sampleRate: 44100
                    }
                });

                this.videoDisplay.srcObject = stream;
                this.currentStream = stream;

            } catch (error) {
                console.error('Error accessing camera:', error);
                this.showAlert('Failed to access camera. Falling back to audio mode.', 'error');
                this.switchToAudioMode();
            }
        }

        switchToAudioMode() {
            this.isVideoMode = false;
            this.videoDisplay.style.display = 'none';
            this.waveform.style.display = 'flex';
            this.waveformPlaceholder.style.display = 'none';
            this.modeToggle.textContent = 'RECORD VIDEO LOG';

            // Stop video stream if active
            if (this.currentStream) {
                this.currentStream.getTracks().forEach(track => track.stop());
                this.currentStream = null;
            }
        }

        async startRecording() {
            // If resuming from pause
            if (this.isPaused && this.mediaRecorder) {
                this.mediaRecorder.resume();
                this.isPaused = false;
                this.isRecording = true;
                this.pausedTime += Date.now() - this.pauseStartTime;
                this.startTimer();
                this.startWaveformVisualization();
                this.updateUI();
                return;
            }

            try {
                let stream;

                if (this.isVideoMode && this.currentStream) {
                    // Use existing video stream
                    stream = this.currentStream;
                } else {
                    // Get new audio stream
                    stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            sampleRate: 44100
                        }
                    });
                }

                this.chunks = [];

                // Determine MIME type with fallback options
                let mimeType;
                if (this.isVideoMode) {
                    // Check if browser supports format testing
                    if (typeof MediaRecorder.isTypeSupported === 'function') {
                        // Try different video formats in order of preference
                        if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9,opus')) {
                            mimeType = 'video/webm;codecs=vp9,opus';
                            console.log('Using video format: vp9 with opus');
                        } else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8,opus')) {
                            mimeType = 'video/webm;codecs=vp8,opus';
                            console.log('Using video format: vp8 with opus');
                        } else if (MediaRecorder.isTypeSupported('video/webm')) {
                            mimeType = 'video/webm';
                            console.log('Using video format: webm default');
                        } else {
                            mimeType = 'video/webm';
                            console.log('Using fallback video format: webm');
                        }
                    } else {
                        // Fallback for browsers without isTypeSupported
                        mimeType = 'video/webm';
                        console.log('Browser does not support format testing, using default: webm');
                    }
                } else {
                    mimeType = 'audio/webm';
                }

                console.log('Creating MediaRecorder with MIME type:', mimeType);
                console.log('Stream tracks:', stream.getTracks().map(t => ({ kind: t.kind, enabled: t.enabled, readyState: t.readyState })));

                let mediaRecorder;
                try {
                    mediaRecorder = new MediaRecorder(stream, { mimeType });
                    console.log('MediaRecorder created successfully with options:', mediaRecorder);
                } catch (mimeError) {
                    console.warn('Failed to create MediaRecorder with MIME type, trying without options:', mimeError);
                    try {
                        mediaRecorder = new MediaRecorder(stream);
                        console.log('MediaRecorder created with default settings:', mediaRecorder);
                    } catch (defaultError) {
                        console.error('Failed to create MediaRecorder even without options:', defaultError);
                        throw new Error('MediaRecorder not supported in this browser');
                    }
                }

                // Assign to class property only after successful creation
                this.mediaRecorder = mediaRecorder;

                this.mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        this.chunks.push(event.data);
                    }
                };

                this.mediaRecorder.onstop = () => {
                    if (!this.isVideoMode) {
                        stream.getTracks().forEach(track => track.stop());
                    }
                    this.stopWaveformVisualization();
                    this.updateUI();
                };

                // Set up audio context for visualization (works for both audio and video)
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                this.analyser = this.audioContext.createAnalyser();
                this.microphone = this.audioContext.createMediaStreamSource(stream);
                this.microphone.connect(this.analyser);

                this.analyser.fftSize = 256;
                this.analyser.smoothingTimeConstant = 0.8;

                // Verify MediaRecorder was created properly
                console.log('Verifying MediaRecorder:', {
                    exists: !!this.mediaRecorder,
                    type: typeof this.mediaRecorder,
                    constructor: this.mediaRecorder ? this.mediaRecorder.constructor.name : 'none',
                    hasStart: this.mediaRecorder && typeof this.mediaRecorder.start === 'function',
                    startType: this.mediaRecorder ? typeof this.mediaRecorder.start : 'none',
                    methods: this.mediaRecorder ? Object.getOwnPropertyNames(this.mediaRecorder) : 'none',
                    prototype: this.mediaRecorder ? Object.getOwnPropertyNames(Object.getPrototypeOf(this.mediaRecorder)) : 'none'
                });

                if (!this.mediaRecorder) {
                    throw new Error('MediaRecorder is null or undefined');
                }

                if (typeof this.mediaRecorder.start !== 'function') {
                    throw new Error(`MediaRecorder.start is not a function, it is: ${typeof this.mediaRecorder.start}`);
                }

                console.log('About to call start() on MediaRecorder:', this.mediaRecorder);
                console.log('MediaRecorder state:', this.mediaRecorder.state);
                console.log('MediaRecorder stream:', this.mediaRecorder.stream);

                // Add a small delay to ensure MediaRecorder is ready
                await new Promise(resolve => setTimeout(resolve, 100));

                console.log('After delay - MediaRecorder state:', this.mediaRecorder.state);
                this.mediaRecorder.start();
                console.log('MediaRecorder.start() called successfully');
                this.isRecording = true;
                this.startTime = Date.now();
                this.startTimer();
                this.startWaveformVisualization();
                this.updateUI();

                const recordingType = this.isVideoMode ? 'video' : 'audio';
                this.showAlert(`${recordingType} recording started`, 'success');

            } catch (error) {
                console.error('Error starting recording:', error);

                if (error.message === 'No supported video format available') {
                    this.showAlert('Video recording not supported in this browser. Switching to audio mode.', 'error');
                    this.switchToAudioMode();
                    return;
                }

                const deviceType = this.isVideoMode ? 'camera' : 'microphone';
                this.showAlert(`Failed to start recording: ${error.message}`, 'error');
            }
        }

        stopRecording() {
            if (this.mediaRecorder && this.mediaRecorder.state === 'recording') {
                this.mediaRecorder.pause();
            }

            this.isRecording = false;
            this.isPaused = true;
            this.pauseStartTime = Date.now();
            this.stopTimer();
            this.updateUI();
        }

        pauseRecording() {
            if (this.isPaused) {
                // Resume
                this.mediaRecorder.resume();
                this.isPaused = false;
                this.pausedTime += Date.now() - this.pauseStartTime;
                this.startTimer();
            } else {
                // Pause
                this.mediaRecorder.pause();
                this.isPaused = true;
                this.pauseStartTime = Date.now();
                this.stopTimer();
            }
            this.updateUI();
        }

        startTimer() {
            this.timerInterval = setInterval(() => {
                const elapsed = (Date.now() - this.startTime - this.pausedTime) / 1000;
                const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
                const seconds = Math.floor(elapsed % 60).toString().padStart(2, '0');
                this.timer.textContent = `${minutes}:${seconds}`;
            }, 1000);
        }

        stopTimer() {
            if (this.timerInterval) {
                clearInterval(this.timerInterval);
                this.timerInterval = null;
            }
        }

        startWaveformVisualization() {
            this.waveformPlaceholder.style.display = 'none';
            this.waveform.classList.add('active');

            const bars = this.waveform.children;
            const bufferLength = this.analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);

            const animate = () => {
                if (!this.isRecording && !this.isPaused) return;

                this.analyser.getByteFrequencyData(dataArray);

                // Update bars based on frequency data
                for (let i = 0; i < bars.length; i++) {
                    const dataIndex = Math.floor(i * bufferLength / bars.length);
                    const value = dataArray[dataIndex] || 0;
                    const height = Math.max(2, (value / 255) * 100);
                    bars[i].style.height = `${height}%`;
                }

                this.animationId = requestAnimationFrame(animate);
            };

            animate();
        }

        stopWaveformVisualization() {
            if (this.animationId) {
                cancelAnimationFrame(this.animationId);
                this.animationId = null;
            }

            this.waveform.classList.remove('active');
            this.waveformPlaceholder.style.display = 'block';

            // Reset bars
            Array.from(this.waveform.children).forEach(bar => {
                bar.style.height = '2px';
            });
        }

        async saveRecording() {
            // First stop the recording if it's still going
            if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {
                this.mediaRecorder.stop();
            }

            if (this.chunks.length === 0) {
                const mediaType = this.isVideoMode ? 'video' : 'audio';
                this.showAlert(`No ${mediaType} data to save`, 'error');
                return;
            }

            const mimeType = this.isVideoMode ? 'video/webm' : 'audio/webm';
            const extension = this.isVideoMode ? '.webm' : '.webm';
            const filename = this.isVideoMode ? `recording${extension}` : `recording${extension}`;

            const mediaBlob = new Blob(this.chunks, { type: mimeType });
            const formData = new FormData();
            formData.append('file', mediaBlob, filename);
            formData.append('media_type', this.isVideoMode ? 'video' : 'audio');

            // Get geolocation
            try {
                const location = await this.getCurrentLocation();
                if (location) {
                    formData.append('latitude', location.latitude.toString());
                    formData.append('longitude', location.longitude.toString());
                    if (location.location_name) {
                        formData.append('location_name', location.location_name);
                    }
                    this.showAlert('Location captured', 'info');
                }
            } catch (error) {
                console.warn('Could not get location:', error);
                this.showAlert('Location unavailable - continuing without location data', 'info');
            }

            this.showUploadProgress();

            try {
                const response = await fetch('/api/logs/upload', {
                    method: 'POST',
                    body: formData
                });

                if (response.ok) {
                    const result = await response.json();
                    const mediaType = this.isVideoMode ? 'video' : 'audio';
                    this.showAlert(`${mediaType} log entry saved! ID: ${result.id}`, 'success');

                    // Redirect to log detail page after 2 seconds
                    setTimeout(() => {
                        window.location.href = `/logs/${result.id}`;
                    }, 2000);
                } else {
                    const errorText = await response.text();
                    throw new Error(`Upload failed: ${response.status} - ${errorText}`);
                }
            } catch (error) {
                console.error('Error uploading:', error);
                this.showAlert(`Failed to save log entry: ${error.message}`, 'error');
            }

            this.hideUploadProgress();
            this.resetRecorder();
        }

        resetRecorder() {
            this.chunks = [];
            this.isRecording = false;
            this.isPaused = false;
            this.startTime = null;
            this.pausedTime = 0;
            this.timer.textContent = '00:00';
            this.updateUI();
        }

        cancelRecording() {
            if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {
                this.mediaRecorder.stop();
            }

            // Clean up streams
            if (this.currentStream && !this.isVideoMode) {
                this.currentStream.getTracks().forEach(track => track.stop());
                this.currentStream = null;
            }

            this.stopWaveformVisualization();
            this.resetRecorder();
            this.showAlert('Recording cancelled', 'info');
        }

        updateUI() {
            if (this.isRecording && !this.isPaused) {
                // Currently recording - overlay is transparent, click to stop
                this.recordingOverlay.classList.add('transparent');
                this.recordingOverlay.textContent = '';
                this.recordingOverlay.onclick = () => this.stopRecording();
                this.cancelBtn.style.display = 'block';
                this.saveBtn.style.display = 'none';
            } else if (this.isPaused || this.chunks.length > 0) {
                // Paused/stopped - overlay shows resume, save button visible
                this.recordingOverlay.classList.remove('transparent');
                this.recordingOverlay.textContent = 'RESUME RECORDING';
                this.recordingOverlay.onclick = () => this.startRecording();
                this.cancelBtn.style.display = 'block';
                this.saveBtn.style.display = 'block';
                this.saveBtn.classList.remove('disabled');
            } else {
                // Ready to start - overlay shows start
                this.recordingOverlay.classList.remove('transparent');
                this.recordingOverlay.textContent = 'START RECORDING';
                this.recordingOverlay.onclick = () => this.startRecording();
                this.cancelBtn.style.display = 'none';
                this.saveBtn.style.display = 'none';
            }
        }

        showUploadProgress() {
            document.getElementById('upload-progress').style.display = 'block';
            this.updateProgress(0, 'Preparing upload...');

            // Simulate progress for better UX
            let progress = 0;
            const interval = setInterval(() => {
                progress += Math.random() * 10;
                if (progress > 90) progress = 90;
                this.updateProgress(progress, 'Uploading audio...');
            }, 500);

            setTimeout(() => {
                clearInterval(interval);
                this.updateProgress(100, 'Processing complete!');
            }, 3000);
        }

        hideUploadProgress() {
            setTimeout(() => {
                document.getElementById('upload-progress').style.display = 'none';
            }, 1000);
        }

        updateProgress(percentage, status) {
            const progressBar = document.getElementById('progress-bar');
            const progressText = document.getElementById('progress-text');
            const progressStatus = document.getElementById('progress-status');

            progressBar.style.width = `${percentage}%`;
            progressText.textContent = `${Math.round(percentage)}%`;
            progressStatus.textContent = status;
        }

        async getCurrentLocation() {
            return new Promise((resolve, reject) => {
                if (!navigator.geolocation) {
                    reject(new Error('Geolocation not supported'));
                    return;
                }

                const options = {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 60000
                };

                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        const location = {
                            latitude: position.coords.latitude,
                            longitude: position.coords.longitude
                        };

                        resolve(location);
                    },
                    (error) => {
                        reject(new Error(`Geolocation error: ${error.message}`));
                    },
                    options
                );
            });
        }

        showAlert(message, type) {
            const alertsContainer = document.getElementById('alerts');
            const alert = document.createElement('div');
            alert.className = `lcars-alert ${type}`;
            alert.textContent = message;

            alertsContainer.appendChild(alert);

            // Remove alert after 5 seconds
            setTimeout(() => {
                if (alert.parentNode) {
                    alert.parentNode.removeChild(alert);
                }
            }, 5000);
        }
    }

    // Initialize recorder
    let recorder;

    document.addEventListener('DOMContentLoaded', function() {
        recorder = new VoiceRecorder();
    });

    function toggleRecording() {
        if (recorder.isRecording) {
            recorder.stopRecording();
        } else if (recorder.isPaused || recorder.chunks.length > 0) {
            recorder.startRecording();
        } else {
            recorder.startRecording();
        }
    }

    function pauseRecording() {
        recorder.pauseRecording();
    }

    function saveRecording() {
        recorder.saveRecording();
    }

    function cancelRecording() {
        recorder.cancelRecording();
    }

    function switchMode() {
        if (recorder.isVideoMode) {
            recorder.switchToAudioMode();
        } else {
            recorder.switchToVideoMode();
        }
    }

    // Handle keyboard shortcuts
    document.addEventListener('keydown', function(event) {
        if (event.code === 'Space' && event.target.tagName !== 'INPUT') {
            event.preventDefault();
            toggleRecording();
        } else if (event.code === 'KeyP' && event.ctrlKey) {
            event.preventDefault();
            pauseRecording();
        } else if (event.code === 'KeyS' && event.ctrlKey) {
            event.preventDefault();
            saveRecording();
        }
    });
</script>
{% endblock %}